/**
 * @file c0_drv.c
 * @author liang.huajun
 * @brief
 * @version 2.5
 * @date 2021-05-26
 *
 * @copyright Copyright (c) 2020
 *
 */

#include "c0_drv.h"

SubC0_HandleTypeDef *hSubC0 = (SubC0_HandleTypeDef *)C0SRAM_ADD_BUFFER;

/**
 * @brief SubC bin
 * SubC0_HandleTypeDef
 * 1. 增加了C0 gint中断唤醒功能
 * 2. 数据交互由SubC0_HandleTypeDef结构体处理, 起始地址是0x08100F80
 * 3. 因为更低功耗需求, 用到了PCI 32.768时钟(C0 eport时钟源切换到了外部32.768时钟)！！！   
 * 
 */
unsigned char g_C0BIN_LPWAKEUP[2788] = {
    0x00, 0x01, 0x00, 0x00, 0x9a, 0x0a, 0x00, 0x00, 0xa8, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0xb6, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0xc4, 0x0a, 0x00, 0x00,
    0xd2, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x94, 0x01, 0x00, 0x00, 0xec, 0x01, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x44, 0x02, 0x00, 0x00, 0x9c, 0x02, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00,
    0x58, 0x01, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00, 0x8c, 0x0a, 0x00, 0x00,
    0x0b, 0x71, 0x10, 0x12, 0x0b, 0x71, 0x11, 0x18, 0x12, 0x10, 0x02, 0x60, 0x03, 0x60, 0x01, 0x60,
    0x04, 0x60, 0x05, 0x60, 0x06, 0x60, 0x07, 0x60, 0x08, 0x60, 0x09, 0x60, 0x0a, 0x60, 0x0b, 0x60,
    0x0c, 0x60, 0x0d, 0x60, 0x0e, 0x60, 0x0f, 0x60, 0x03, 0x7f, 0xff, 0xf7, 0x80, 0x0f, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xb4, 0x09, 0x00, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0xd7, 0x32,
    0x27, 0x35, 0xd6, 0x32, 0x26, 0x35, 0x06, 0xc6, 0x66, 0x01, 0x36, 0x34, 0x66, 0x01, 0x07, 0xd6,
    0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0xc7, 0x63,
    0x27, 0x35, 0xc6, 0x63, 0x26, 0x35, 0x06, 0x86, 0x46, 0x35, 0x07, 0x96, 0xc7, 0x63, 0x27, 0x35,
    0xc6, 0x63, 0x26, 0x35, 0x06, 0x86, 0x46, 0x31, 0x07, 0x96, 0x04, 0x77, 0x07, 0x87, 0x04, 0x76,
    0x07, 0x96, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x00, 0x00, 0xe0, 0x0a, 0x00, 0x00,
    0x00, 0x00, 0x2b, 0x16, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32,
    0x26, 0x35, 0x76, 0xa6, 0x46, 0x01, 0x06, 0x34, 0x46, 0x01, 0x77, 0xb6, 0x00, 0x1e, 0x0e, 0x77,
    0x07, 0x87, 0x47, 0xa7, 0x07, 0x2a, 0xfb, 0xe7, 0x0c, 0x77, 0x07, 0x87, 0x16, 0x60, 0x47, 0xb6,
    0x0a, 0x77, 0x07, 0x87, 0x16, 0x60, 0x77, 0xb6, 0xc7, 0x63, 0x27, 0x35, 0xc6, 0x63, 0x26, 0x35,
    0x06, 0x86, 0x66, 0x35, 0x07, 0x96, 0x04, 0x77, 0x07, 0x87, 0x06, 0x60, 0x47, 0xb6, 0x80, 0x12,
    0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x00, 0x00, 0xe0, 0x0a, 0x00, 0x00, 0x30, 0x24, 0x00, 0x98,
    0x08, 0x12, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x76, 0xa6, 0x46, 0x01, 0x16, 0x34,
    0x46, 0x01, 0x77, 0xb6, 0x00, 0x1e, 0x0e, 0x77, 0x07, 0x87, 0x47, 0xa7, 0x07, 0x2a, 0xfb, 0xe7,
    0x0c, 0x77, 0x07, 0x87, 0x16, 0x60, 0x47, 0xb6, 0x0a, 0x77, 0x07, 0x87, 0x16, 0x60, 0xa7, 0xb6,
    0xc7, 0x63, 0x27, 0x35, 0xc6, 0x63, 0x26, 0x35, 0x06, 0x86, 0x66, 0x35, 0x07, 0x96, 0x04, 0x77,
    0x07, 0x87, 0x06, 0x60, 0x47, 0xb6, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x00, 0x00,
    0xe0, 0x0a, 0x00, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32,
    0x26, 0x35, 0x76, 0xa6, 0x46, 0x01, 0x46, 0x34, 0x46, 0x01, 0x77, 0xb6, 0x00, 0x1e, 0x0e, 0x77,
    0x07, 0x87, 0x47, 0xa7, 0x07, 0x2a, 0xfb, 0xe7, 0x0c, 0x77, 0x07, 0x87, 0x16, 0x60, 0x47, 0xb6,
    0x0a, 0x77, 0x07, 0x87, 0x16, 0x60, 0xd7, 0xb6, 0xc7, 0x63, 0x27, 0x35, 0xc6, 0x63, 0x26, 0x35,
    0x06, 0x86, 0x66, 0x35, 0x07, 0x96, 0x04, 0x77, 0x07, 0x87, 0x06, 0x60, 0x47, 0xb6, 0x80, 0x12,
    0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x00, 0x00, 0xe0, 0x0a, 0x00, 0x00, 0x30, 0x24, 0x00, 0x98,
    0x08, 0x12, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x76, 0xa6, 0x46, 0x01, 0x56, 0x34,
    0x46, 0x01, 0x77, 0xb6, 0x00, 0x1e, 0x0e, 0x77, 0x07, 0x87, 0x47, 0xa7, 0x07, 0x2a, 0xfb, 0xe7,
    0x0c, 0x77, 0x07, 0x87, 0x16, 0x60, 0x47, 0xb6, 0x0a, 0x77, 0x07, 0x87, 0xf7, 0x20, 0x16, 0x60,
    0x07, 0xb6, 0xc7, 0x63, 0x27, 0x35, 0xc6, 0x63, 0x26, 0x35, 0x06, 0x86, 0x66, 0x35, 0x07, 0x96,
    0x04, 0x77, 0x07, 0x87, 0x06, 0x60, 0x47, 0xb6, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00,
    0xe0, 0x0a, 0x00, 0x00, 0x70, 0x24, 0x10, 0x98, 0x08, 0x12, 0x08, 0x92, 0x27, 0x33, 0x77, 0x20,
    0x26, 0x33, 0x76, 0x20, 0x06, 0x86, 0x85, 0x2c, 0x56, 0x1f, 0x07, 0x96, 0x27, 0x33, 0x77, 0x21,
    0x36, 0x60, 0x07, 0x96, 0x07, 0x64, 0x27, 0x35, 0x06, 0x64, 0x26, 0x35, 0x06, 0x86, 0xe6, 0x35,
    0x07, 0x96, 0xc7, 0x32, 0x27, 0x35, 0x06, 0x60, 0x07, 0xd6, 0xd7, 0x32, 0x27, 0x35, 0x06, 0x60,
    0x07, 0xd6, 0x07, 0x60, 0x72, 0x12, 0x80, 0x12, 0x10, 0x88, 0x70, 0x20, 0xcf, 0x00, 0xbe, 0xbe,
    0x70, 0x24, 0x10, 0x98, 0x08, 0x12, 0x08, 0x92, 0x08, 0x87, 0x14, 0x76, 0x07, 0x96, 0x00, 0x1e,
    0x08, 0x87, 0x47, 0xa7, 0x07, 0x2a, 0xfc, 0xe7, 0x08, 0x87, 0x16, 0x60, 0x47, 0xb6, 0x08, 0x87,
    0x06, 0x60, 0x77, 0xb6, 0x08, 0x87, 0x06, 0x60, 0xa7, 0xb6, 0x08, 0x87, 0x06, 0x60, 0xd7, 0xb6,
    0x08, 0x87, 0xf7, 0x20, 0x06, 0x60, 0x07, 0xb6, 0x08, 0x87, 0x27, 0x21, 0x06, 0x60, 0x07, 0xb6,
    0x08, 0x87, 0x57, 0x21, 0x06, 0x60, 0x07, 0xb6, 0x08, 0x87, 0x06, 0x60, 0x47, 0xb6, 0x07, 0x60,
    0x72, 0x12, 0x80, 0x12, 0x10, 0x88, 0x70, 0x20, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x13,
    0xb0, 0x24, 0x20, 0x98, 0x08, 0x12, 0x08, 0x92, 0x18, 0x93, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32,
    0x26, 0x35, 0x26, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b,
    0x36, 0x12, 0x46, 0x01, 0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x27, 0xb6, 0x08, 0x86,
    0x07, 0x65, 0x76, 0x0f, 0x13, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6,
    0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01,
    0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x37, 0xb6, 0xb6, 0xf1, 0x08, 0x86, 0x17, 0x65,
    0x76, 0x0f, 0x21, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6, 0x65, 0x12,
    0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e,
    0x46, 0x01, 0x37, 0xb6, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x56, 0xa6, 0x65, 0x12,
    0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e,
    0x46, 0x01, 0x57, 0xb6, 0x91, 0xf1, 0x08, 0x86, 0x27, 0x65, 0x76, 0x0f, 0x23, 0xe0, 0xe7, 0x32,
    0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60,
    0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x37, 0xb6, 0xe7, 0x32,
    0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x56, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60,
    0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01,
    0x57, 0xb6, 0x6a, 0xf1, 0x08, 0x86, 0x37, 0x65, 0x76, 0x0f, 0x49, 0xe0, 0xe7, 0x32, 0x27, 0x35,
    0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12,
    0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x37, 0xb6,
    0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32, 0x27, 0x35, 0x07, 0xc7, 0x75, 0x12, 0x65, 0x01, 0x18, 0x87,
    0x67, 0x01, 0x77, 0x1c, 0x34, 0x60, 0x43, 0x12, 0x73, 0x1b, 0x37, 0x12, 0x67, 0x01, 0xf7, 0x01,
    0x67, 0x01, 0x57, 0x16, 0x67, 0x01, 0x06, 0xd7, 0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32, 0x27, 0x35,
    0x07, 0xc7, 0x75, 0x12, 0x65, 0x01, 0x18, 0x87, 0x67, 0x01, 0x77, 0x1c, 0x14, 0x60, 0x43, 0x12,
    0x73, 0x1b, 0x37, 0x12, 0x67, 0x01, 0x57, 0x1e, 0x67, 0x01, 0x06, 0xd7, 0xe7, 0x32, 0x27, 0x35,
    0xe6, 0x32, 0x26, 0x35, 0x26, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12,
    0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x27, 0xb6, 0x1d, 0xf1, 0x08, 0x86,
    0x47, 0x65, 0x76, 0x0f, 0x49, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6,
    0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01,
    0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x37, 0xb6, 0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32,
    0x27, 0x35, 0x07, 0xc7, 0x75, 0x12, 0x65, 0x01, 0x18, 0x87, 0x67, 0x01, 0x77, 0x1c, 0x34, 0x60,
    0x43, 0x12, 0x73, 0x1b, 0x37, 0x12, 0x67, 0x01, 0xf7, 0x01, 0x67, 0x01, 0x57, 0x16, 0x67, 0x01,
    0x06, 0xd7, 0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32, 0x27, 0x35, 0x07, 0xc7, 0x75, 0x12, 0x65, 0x01,
    0x18, 0x87, 0x67, 0x01, 0x77, 0x1c, 0x24, 0x60, 0x43, 0x12, 0x73, 0x1b, 0x37, 0x12, 0x67, 0x01,
    0x57, 0x1e, 0x67, 0x01, 0x06, 0xd7, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x26, 0xa6,
    0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01,
    0x56, 0x1e, 0x46, 0x01, 0x27, 0xb6, 0xd0, 0xf0, 0x08, 0x86, 0x57, 0x65, 0x76, 0x0f, 0x35, 0xe0,
    0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86,
    0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0xf6, 0x01, 0x46, 0x01, 0x56, 0x16,
    0x46, 0x01, 0x37, 0xb6, 0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32, 0x27, 0x35, 0x07, 0xc7, 0x75, 0x12,
    0x65, 0x01, 0x18, 0x87, 0x67, 0x01, 0x77, 0x1c, 0x34, 0x60, 0x43, 0x12, 0x73, 0x1b, 0x37, 0x12,
    0x67, 0x01, 0x57, 0x1e, 0x67, 0x01, 0x06, 0xd7, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35,
    0x26, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12,
    0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x27, 0xb6, 0x97, 0xf0, 0x08, 0x86, 0x67, 0x65, 0x76, 0x0f,
    0x47, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x36, 0xa6, 0x65, 0x12, 0x45, 0x01,
    0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0xf6, 0x01, 0x46, 0x01,
    0x56, 0x16, 0x46, 0x01, 0x37, 0xb6, 0xe6, 0x32, 0x26, 0x35, 0xe7, 0x32, 0x27, 0x35, 0x07, 0xc7,
    0x75, 0x12, 0x65, 0x01, 0x18, 0x87, 0x67, 0x01, 0x77, 0x1c, 0x34, 0x60, 0x43, 0x12, 0x73, 0x1b,
    0x37, 0x12, 0x67, 0x01, 0xf7, 0x01, 0x67, 0x01, 0x57, 0x16, 0x67, 0x01, 0x06, 0xd7, 0xe7, 0x32,
    0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x96, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60,
    0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x97, 0xb6, 0xe7, 0x32,
    0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x26, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60,
    0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x27, 0xb6, 0x4c, 0xf0,
    0x08, 0x86, 0x77, 0x65, 0x76, 0x0f, 0x48, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35,
    0x36, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12,
    0x46, 0x01, 0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x37, 0xb6, 0xe6, 0x32, 0x26, 0x35,
    0xe7, 0x32, 0x27, 0x35, 0x07, 0xc7, 0x75, 0x12, 0x65, 0x01, 0x18, 0x87, 0x67, 0x01, 0x77, 0x1c,
    0x34, 0x60, 0x43, 0x12, 0x73, 0x1b, 0x37, 0x12, 0x67, 0x01, 0xf7, 0x01, 0x67, 0x01, 0x57, 0x16,
    0x67, 0x01, 0x06, 0xd7, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x96, 0xa6, 0x65, 0x12,
    0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0xf6, 0x01,
    0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x97, 0xb6, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35,
    0x26, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12,
    0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x27, 0xb6, 0x07, 0x60, 0x72, 0x12, 0x80, 0x12, 0x20, 0x88,
    0xb0, 0x20, 0xcf, 0x00, 0xb0, 0x24, 0x20, 0x98, 0x08, 0x12, 0x08, 0x92, 0x18, 0x93, 0x08, 0x86,
    0x27, 0x64, 0x76, 0x0f, 0x21, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x66, 0xa6,
    0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01,
    0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x67, 0xb6, 0x67, 0x64, 0xc7, 0x38, 0x66, 0x64,
    0xc6, 0x38, 0x76, 0x85, 0x18, 0x86, 0xf6, 0x20, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12,
    0xf6, 0x01, 0x56, 0x16, 0x77, 0x96, 0x46, 0xf0, 0x08, 0x86, 0x07, 0x64, 0x76, 0x0f, 0x1f, 0xe0,
    0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x66, 0xa6, 0x65, 0x12, 0x45, 0x01, 0x18, 0x86,
    0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01, 0x56, 0x1e, 0x46, 0x01, 0x67, 0xb6,
    0x67, 0x64, 0xc7, 0x38, 0x66, 0x64, 0xc6, 0x38, 0x76, 0x85, 0x18, 0x86, 0xf6, 0x20, 0x14, 0x60,
    0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0xf6, 0x01, 0x56, 0x16, 0x77, 0x96, 0x23, 0xf0, 0x08, 0x86,
    0x17, 0x64, 0x76, 0x0f, 0x1f, 0xe0, 0xe7, 0x32, 0x27, 0x35, 0xe6, 0x32, 0x26, 0x35, 0x66, 0xa6,
    0x65, 0x12, 0x45, 0x01, 0x18, 0x86, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12, 0x46, 0x01,
    0xf6, 0x01, 0x46, 0x01, 0x56, 0x16, 0x46, 0x01, 0x67, 0xb6, 0x67, 0x64, 0xc7, 0x38, 0x66, 0x64,
    0xc6, 0x38, 0x76, 0x85, 0x18, 0x86, 0xf6, 0x20, 0x14, 0x60, 0x43, 0x12, 0x63, 0x1b, 0x36, 0x12,
    0x56, 0x1e, 0x77, 0x96, 0x07, 0x60, 0x72, 0x12, 0x80, 0x12, 0x20, 0x88, 0xb0, 0x20, 0xcf, 0x00,
    0xb0, 0x24, 0x10, 0x9f, 0x20, 0x98, 0x08, 0x12, 0x08, 0x92, 0x67, 0x64, 0xc7, 0x38, 0x06, 0x60,
    0x67, 0x96, 0x08, 0x87, 0x67, 0xa7, 0x72, 0x12, 0x03, 0x60, 0x15, 0x7f, 0x08, 0x87, 0x97, 0xa7,
    0x72, 0x12, 0x13, 0x60, 0x13, 0x7f, 0x08, 0x87, 0xc7, 0xa7, 0x72, 0x12, 0x43, 0x60, 0x10, 0x7f,
    0x08, 0x87, 0xf7, 0xa7, 0x72, 0x12, 0x53, 0x60, 0x0e, 0x7f, 0x08, 0x87, 0x57, 0xa7, 0x72, 0x12,
    0x03, 0x60, 0x0c, 0x7f, 0x08, 0x87, 0x87, 0xa7, 0x72, 0x12, 0x13, 0x60, 0x0a, 0x7f, 0x08, 0x87,
    0xb7, 0xa7, 0x72, 0x12, 0x43, 0x60, 0x07, 0x7f, 0x08, 0x87, 0xe7, 0xa7, 0x72, 0x12, 0x53, 0x60,
    0x05, 0x7f, 0x07, 0x60, 0x72, 0x12, 0x80, 0x12, 0x10, 0x8f, 0x20, 0x88, 0xb0, 0x20, 0xcf, 0x00,
    0x74, 0x07, 0x00, 0x00, 0xa0, 0x03, 0x00, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0x07, 0x63,
    0x27, 0x35, 0x06, 0x63, 0x26, 0x35, 0x06, 0x85, 0x06, 0x60, 0xf6, 0x35, 0x56, 0x1e, 0x07, 0x96,
    0x07, 0x63, 0x27, 0x35, 0x06, 0x63, 0x26, 0x35, 0x06, 0x86, 0x06, 0x31, 0x07, 0x96, 0x27, 0x33,
    0xf7, 0x20, 0x26, 0x33, 0xf6, 0x20, 0x06, 0x86, 0x46, 0x34, 0x07, 0x96, 0x00, 0x1e, 0x27, 0x33,
    0xf7, 0x20, 0x07, 0x86, 0xc7, 0x32, 0x67, 0x16, 0x07, 0x2a, 0xf9, 0xef, 0x27, 0x33, 0x37, 0x21,
    0x26, 0x33, 0x36, 0x21, 0x06, 0x86, 0x66, 0x34, 0x07, 0x96, 0x27, 0x33, 0x77, 0x21, 0x36, 0x60,
    0x07, 0x96, 0x27, 0x33, 0x26, 0x33, 0x06, 0x86, 0x36, 0x35, 0x07, 0x96, 0x27, 0x33, 0x26, 0x33,
    0x06, 0x86, 0x96, 0x35, 0x07, 0x96, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0xbe, 0xbe,
    0x70, 0x24, 0x00, 0x9f, 0x10, 0x98, 0x08, 0x12, 0x27, 0x33, 0x26, 0x33, 0x06, 0x86, 0x06, 0x34,
    0x07, 0x96, 0x0f, 0x77, 0x0f, 0x76, 0x06, 0x86, 0x26, 0x34, 0x07, 0x96, 0x0e, 0x77, 0x0d, 0x76,
    0x06, 0x86, 0x26, 0x34, 0x07, 0x96, 0x47, 0x63, 0x27, 0x35, 0x06, 0x60, 0x07, 0x96, 0x87, 0x63,
    0x27, 0x35, 0x06, 0x60, 0x07, 0x96, 0x08, 0x77, 0x06, 0x60, 0x07, 0x96, 0xc7, 0x66, 0x27, 0x35,
    0x07, 0x76, 0x07, 0x96, 0x07, 0x7f, 0x80, 0x12, 0x00, 0x8f, 0x10, 0x88, 0x70, 0x20, 0xcf, 0x00,
    0xa4, 0x00, 0x04, 0x00, 0xa0, 0x00, 0x04, 0x00, 0x94, 0x00, 0x04, 0x00, 0x78, 0xa6, 0x00, 0x07,
    0xd8, 0x08, 0x00, 0x00, 0x70, 0x24, 0x00, 0x9f, 0x10, 0x98, 0x08, 0x12, 0x2d, 0x77, 0x07, 0x87,
    0x72, 0x12, 0x2c, 0x7f, 0x2b, 0x77, 0x07, 0x87, 0x72, 0x12, 0x2b, 0x7f, 0x29, 0x77, 0x07, 0x87,
    0x72, 0x12, 0x2a, 0x7f, 0xd7, 0x2d, 0xf7, 0x28, 0x86, 0x2c, 0x07, 0x96, 0xc7, 0x63, 0x27, 0x35,
    0xc6, 0x63, 0x26, 0x35, 0x06, 0x86, 0x76, 0x35, 0x07, 0x96, 0xd7, 0x2d, 0xf7, 0x28, 0xd6, 0x2d,
    0xf6, 0x28, 0x06, 0x86, 0x86, 0x35, 0x07, 0x96, 0x22, 0x7f, 0x1d, 0x77, 0x07, 0x87, 0x21, 0x76,
    0x07, 0x96, 0x01, 0xf0, 0x00, 0x1e, 0x1a, 0x77, 0x07, 0x87, 0x77, 0xa7, 0x07, 0x2a, 0xfa, 0xe7,
    0x18, 0x77, 0x07, 0x87, 0xa7, 0xa7, 0x07, 0x2a, 0xf5, 0xe7, 0x15, 0x77, 0x07, 0x87, 0xd7, 0xa7,
    0x07, 0x2a, 0xf0, 0xe7, 0x13, 0x77, 0x07, 0x87, 0xf7, 0x20, 0x07, 0xa7, 0x07, 0x2a, 0xea, 0xe7,
    0x10, 0x77, 0x07, 0x87, 0x27, 0x21, 0x07, 0xa7, 0x07, 0x2a, 0xe4, 0xe7, 0x0d, 0x77, 0x07, 0x87,
    0x57, 0x21, 0x07, 0xa7, 0x07, 0x2a, 0xde, 0xe7, 0x0a, 0x77, 0x07, 0x87, 0x47, 0xa7, 0x07, 0x2a,
    0xd9, 0xe7, 0x07, 0x77, 0x07, 0x87, 0x07, 0x86, 0x0c, 0x77, 0x76, 0x0f, 0xd3, 0xe7, 0x27, 0x33,
    0x37, 0x20, 0x26, 0x33, 0x36, 0x20, 0x06, 0x86, 0x06, 0x34, 0x07, 0x96, 0xcb, 0xf7, 0x00, 0x00,
    0xe0, 0x0a, 0x00, 0x00, 0xf4, 0x02, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x60, 0x08, 0x00, 0x00,
    0x50, 0x09, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x16, 0x00, 0x00, 0x2b, 0x1c, 0x30, 0x24, 0x00, 0x98,
    0x08, 0x12, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12,
    0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0x80, 0x12,
    0x00, 0x88, 0x30, 0x20, 0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0x80, 0x12, 0x00, 0x88,
    0x30, 0x20, 0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20,
    0xcf, 0x00, 0x30, 0x24, 0x00, 0x98, 0x08, 0x12, 0x80, 0x12, 0x00, 0x88, 0x30, 0x20, 0xcf, 0x00,
    0x80, 0x0f, 0x00, 0x00};

__weak void SubC0_gint0_callback(void)
{
   // printf("SubC0 gint0 irq\n");
}
__weak void SubC0_gint1_callback(void)
{
   // printf("SubC0 gint1 irq\n");
}
__weak void SubC0_gint4_callback(void)
{
   // printf("SubC0 gint4 irq\n");
}
__weak void SubC0_gint5_callback(void)
{
   // printf("SubC0 gint5 irq\n");
}

__weak uint32_t drv_SubC0_callback(void)
{
    uint32_t timeout = 3600; // 30us

    // UART_Debug_Init(SCI1, g_ips_clk, 115200);
    // IO_Latch_Clr();
    // printf("SubC0 irq\n");

    hSubC0 = (SubC0_HandleTypeDef *)C0SRAM_ADD_BUFFER;
    drv_SubC0_sendM2S(); // 唤醒C0
    if (drv_SubC0_waitReady(7200) != STATUS_OK)
    {
        return STATUS_BUSY;
    }

    while (hSubC0->Lock != 0)
    {
        timeout--;
        if (timeout == 0)
        {
            return STATUS_BUSY;
        }
    }
    hSubC0->Lock = 0x01;

    if (hSubC0->gint0.IE != 0)
    {
        hSubC0->gint0.IE = 0;
        SubC0_gint0_callback();
    }
    if (hSubC0->gint1.IE != 0)
    {
        hSubC0->gint1.IE = 0;
        SubC0_gint1_callback();
    }
    if (hSubC0->gint4.IE != 0)
    {
        hSubC0->gint4.IE = 0;
        SubC0_gint4_callback();
    }
    if (hSubC0->gint5.IE != 0)
    {
        hSubC0->gint5.IE = 0;
        SubC0_gint5_callback();
    }
    hSubC0->Lock = 0;

    /* 清中断标志位 */
    timeout = 3600;                        // 30us
    CPM->CPM_CHIPCFGR |= (1u << 20);       // Sub System to Main System Interrupt Clear
    while (CPM->CPM_CHIPCFGR & (1u << 21)) // clear 源头
    {
        timeout--;
        if (timeout == 0)
        {
            return STATUS_BUSY;
        }
    }
    CPM->CPM_CHIPCFGR &= ~(1u << 20);
    CPM->CPM_PADWKINTCR |= (1u << 7);
    return STATUS_OK;
}

/**
 * @brief
 *
 */
void SUBC0_IRQHandler(void)
{
    drv_SubC0_callback();
}

/**
 * @brief
 *
 */
void c0_read4KSram(void)
{
    volatile uint8_t *pu8 = (uint8_t *)0x08100000;
    printf("\r\n");
    for (uint16_t i = 0; i < 4096; i++)
    {
        if (i % 16 == 0)
        {
            printf("\r\n");
        }
        printf("0x%02x, ", pu8[i]);
    }
    printf("\r\n");
}

/**
 * @brief
 *
 */
void c0_readStruct(const uint8_t *buf, const uint16_t size)
{
    for (uint16_t i = 0; i < size; i++)
    {
        if (i % 16 == 0)
        {
            printf("\r\n");
        }
        printf("0x%02x, ", buf[i]);
    }
    printf("\r\n");
}

/*******************************************************************************
 * Function Name  : drv_SubC0_loadBin
 * Description    : 加载bin到C0内存
 * Input          : - bin_data: bin数据
 *                  - size：大小
 *
 * Output         : None
 * Return         : None
 ******************************************************************************/
void drv_SubC0_loadBin(uint8_t *bin_data, int size)
{
    //  while(size--)
    //    (*(volatile uint8_t *) (0x08100000 + size)) = *(bin_data+size);
    memcpy((void *)0x08100000, bin_data, size);
}

/**
 * @brief M4发送M2S中断信号唤醒C0.
 * 
 * @return uint32_t[out] STATUS_OK
 */
uint32_t drv_SubC0_sendM2S(void)
{
    CPM->CPM_CHIPCFGR |= (1u << 22); // 唤醒C0
    return STATUS_OK;
}

/**
 * @brief 确认C0已经ready, 再执行后续操作.
 * 
 * @param[in] cnt 超时计数
 * @return uint32_t 
 * ex. drv_SubC0_waitReady(7200); // 60us ~ cpu-120mhz
 */
uint32_t drv_SubC0_waitReady(uint16_t cnt)
{
    const uint16_t temp = cnt;
    hSubC0 = (SubC0_HandleTypeDef *)C0SRAM_ADD_BUFFER;
    while ((CPM->CPM_PWRSR & (1 << 4)) == 0) // wait for c0sub system power ready.
    {
        cnt--;
        if (cnt == 0)
        {
            return STATUS_BUSY;
        }
    }
    cnt = temp;
    while ((CPM->CPM_PWRSR & 0x2100) != 0x2100) // wait for m2s bus ready & bus reset released.
    {
        cnt--;
        if (cnt == 0)
        {
            return STATUS_BUSY;
        }
    }
    return STATUS_OK;
}

/**
 * @brief 配置SubC0 IO口的输入输出功能.
 * 
 * @param GpioNo 
 * @param GpioDir GPIO_INPUT/GPIO_OUTPUT
 */
void drv_SubC0_ConfigGpio(SubC0_PINx GpioNo, uint8_t GpioDir)
{
    volatile uint32_t *pu32_CPM_WKPPADCR = (uint32_t *)0x081400C8;

    if (GpioNo > SUBC0_WAKEUP1)
        return;
    if (GpioDir == GPIO_INPUT)
    {
        if (GpioNo < SUBC0_GINT8)
        {
            C0_EPORT0->EPDDR &= ~(1 << GpioNo);
        }
        else if (GpioNo < SUBC0_WAKEUP0)
        {
            C0_EPORT1->EPDDR &= ~(1 << (GpioNo - SUBC0_GINT8));
        }
        else // config wakeup pin
        {
            *pu32_CPM_WKPPADCR &= ~(1u << (8 + GpioNo - SUBC0_WAKEUP0)); // input
            *pu32_CPM_WKPPADCR |= (1u << (0 + GpioNo - SUBC0_WAKEUP0));
        }
    }
    else // output
    {
        if (GpioNo < SUBC0_GINT8)
        {
            C0_EPORT0->EPDDR |= (1 << GpioNo);
            C0_EPORT0->EPIER &= ~(0x01 << GpioNo); //when intterrupt cfg to output should disable pin interrupt 
            C0_EPORT0->EPPAR &= ~(3u << (GpioNo << 1));//when intterrupt cfg to output should cfg EPPAR to 0
        }
        else if (GpioNo < SUBC0_WAKEUP0)
        {
            C0_EPORT1->EPDDR |= (1 << (GpioNo - SUBC0_GINT8));
            C0_EPORT1->EPIER &= ~(0x01 << ((GpioNo - SUBC0_GINT8))); //when intterrupt cfg to output should disable pin interrupt
            C0_EPORT1->EPPAR &= ~(3u << ((GpioNo - SUBC0_GINT8)<< 1));//when intterrupt cfg to output should cfg EPPAR to 0
        }
        else // config wakeup pin
        {
            *pu32_CPM_WKPPADCR |= (1u << (8 + GpioNo - SUBC0_WAKEUP0)); // output
            *pu32_CPM_WKPPADCR &= ~(1u << (0 + GpioNo - SUBC0_WAKEUP0));
        }
    } 
}

/**
 * @brief 配置SubC0 IO口的输出电平.
 * 
 * @param GpioNo 
 * @param bitVal Bit_SET/Bit_RESET
 */
void drv_SubC0_WriteGpioData(SubC0_PINx GpioNo, uint8_t bitVal)
{
    volatile uint32_t *pu32_CPM_WKPPADCR = (uint32_t *)0x081400C8;
    if (GpioNo > SUBC0_WAKEUP1)
        return;
    if (GpioNo < SUBC0_GINT8)
    {
        if (bitVal == Bit_SET)
        {
            C0_EPORT0->EPDR |= (Bit_SET << GpioNo);
        }
        else
        {
            C0_EPORT0->EPDR &= ~(Bit_SET << GpioNo);
        }
    }
    else if (GpioNo < SUBC0_WAKEUP0)
    {
        if (bitVal == Bit_SET)
        {
            C0_EPORT1->EPDR |= (Bit_SET << (GpioNo - SUBC0_GINT8));
        }
        else
        {
            C0_EPORT1->EPDR &= ~(Bit_SET << (GpioNo - SUBC0_GINT8));
        }
    }
    else // wakeup pin
    {
        if (bitVal == Bit_SET)
        {
            *pu32_CPM_WKPPADCR |= (1u << (12 + GpioNo - SUBC0_WAKEUP0));
        }
        else
        {
            *pu32_CPM_WKPPADCR &= ~(1u << (12 + GpioNo - SUBC0_WAKEUP0));
        }
    }
}

/**
 * @brief 读SubC0 IO口的电平.
 * 
 * @param GpioNo 
 * @return uint8_t 
 */
uint8_t drv_SubC0_ReadGpioData(SubC0_PINx GpioNo)
{
    if (GpioNo > SUBC0_WAKEUP1)
        return 0xFF;

    if (GpioNo < SUBC0_GINT8)
    {
        if (C0_EPORT0->EPPDR & (1u << GpioNo))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else if (GpioNo < SUBC0_WAKEUP0)
    {
        if (C0_EPORT1->EPPDR & (1u << (GpioNo - SUBC0_GINT8)))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else // wakeup pin
    {
        const volatile uint32_t pu32_CPM_WKPCSR = *(uint32_t *)0x0814009C;
        const volatile uint32_t pu32_CPM_WKPPADCR = *(uint32_t *)0x081400C8;

        if ((pu32_CPM_WKPPADCR & (1u << (8 + GpioNo - SUBC0_WAKEUP0))) &&
            ((pu32_CPM_WKPPADCR & (1u << (0 + GpioNo - SUBC0_WAKEUP0))) == 0)) // output
        {
            if (pu32_CPM_WKPPADCR & (1u << (12 + GpioNo - SUBC0_WAKEUP0)))
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        else if (((pu32_CPM_WKPPADCR & (1u << (8 + GpioNo - SUBC0_WAKEUP0))) == 0) &&
                 (pu32_CPM_WKPPADCR & (1u << (0 + GpioNo - SUBC0_WAKEUP0)))) // input
        {
            if (pu32_CPM_WKPCSR & (1u << (16 + GpioNo - SUBC0_WAKEUP0)))
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }
        return 0xFF;
    }
}

/*******************************************************************************
* Function Name  : EPORT_ITTypeConfig
* Description    : 设置SubC0_PINx脚的中断触发方式，并使能中断
* Input          : - SubC0_PINx: SubC0 Pin；
*                  - IntMode:中断触发方式
*                            GPIO_INT_RISING_EDGE:上升沿触发
*                            GPIO_INT_FALLING_EDGE:下降沿触发
*                            GPIO_INT_RISING_FALLING_EDGE:上升沿或下降沿触发
*
* Output         : None
* Return         : None
******************************************************************************/
void drv_SubC0_ITTypeConfig(SubC0_PINx GpioNo, uint8_t IntMode)
{
    if (GpioNo > SUBC0_WAKEUP1)
        return ;
    
    //禁止中断
    if (GpioNo < SUBC0_GINT8)
    {
        C0_EPORT0->EPIER &= ~(0x01 << GpioNo);
    }
    else if (GpioNo < SUBC0_WAKEUP0)
    {
        C0_EPORT1->EPIER &= ~(0x01 << ((GpioNo - SUBC0_GINT8)));
    }
    else//wake up pin
    {

    }
    
    //配置输入
    if (GpioNo < SUBC0_GINT8)
    {
        C0_EPORT0->EPDDR &= ~(1 << GpioNo);
    }
    else if (GpioNo < SUBC0_WAKEUP0)
    {
        C0_EPORT1->EPDDR &= ~(1 << (GpioNo - SUBC0_GINT8));
    }
    else // config wakeup pin
    {
    }

    switch (IntMode)
    {
        case GPIO_INT_RISING_EDGE:
            if (GpioNo < SUBC0_GINT8)
            {
                C0_EPORT0->EPPAR &= ~(3u << (GpioNo << 1));
                C0_EPORT0->EPPAR |= (1u << (GpioNo << 1));
            }
            else if(GpioNo < SUBC0_WAKEUP0)
            {
                C0_EPORT1->EPPAR &= ~(3u << ((GpioNo - SUBC0_GINT8) << 1));
                C0_EPORT1->EPPAR |= (1u << ((GpioNo - SUBC0_GINT8) << 1));
            }
            else//wake up
            {
            }
        break;
        case GPIO_INT_FALLING_EDGE:
            if (GpioNo < SUBC0_GINT8)
            {
                C0_EPORT0->EPPAR &= ~(3u << (GpioNo << 1));
                C0_EPORT0->EPPAR |= (2u << (GpioNo << 1));
            }
            else if(GpioNo < SUBC0_WAKEUP0)
            {
                C0_EPORT1->EPPAR &= ~(3u << ((GpioNo - SUBC0_GINT8) << 1));
                C0_EPORT1->EPPAR |= (2u << ((GpioNo - SUBC0_GINT8) << 1));
            }
            else//wake up
            {

            }
        break;
        case GPIO_INT_RISING_FALLING_EDGE:
            if (GpioNo < SUBC0_GINT8)
            {
                //C0_EPORT0->EPPAR &= ~(3u << (GpioNo << 1));
                C0_EPORT0->EPPAR |= (3u << (GpioNo << 1));
            }
            else if(GpioNo < SUBC0_WAKEUP0)
            {
                //C0_EPORT1->EPPAR &= ~(3u << ((GpioNo - SUBC0_GINT8) << 1));
                C0_EPORT1->EPPAR |= (3u << ((GpioNo - SUBC0_GINT8) << 1));
            }
            else//wake up
            {

            }
        break;
        default :break;    
    }

    //使能中断
    if (GpioNo < SUBC0_GINT8)
    {
        C0_EPORT0->EPIER |= (1u << GpioNo);
    }
    else if(GpioNo < SUBC0_WAKEUP0)
    {
        C0_EPORT1->EPIER |= (1u << (GpioNo - SUBC0_GINT8));
    }
    else //wake up
    {

    }
}

/*******************************************************************************
* Function Name  : drv_SubC0_ITConfig
* Description    : EPORT中断使能控制
* Input          : - SubC0_PINx: EPORT Pin；
*                  - NewState：new state of the specified EPORT interrupts.
*                              This parameter can be: ENABLE or DISABLE.
*
* Output         : None
* Return         : None
******************************************************************************/
void drv_SubC0_ITConfig(SubC0_PINx GpioNo, FunctionalState NewState)
{
    if (GpioNo > SUBC0_WAKEUP1)
        return;
    if (NewState != DISABLE)
    {
        if (GpioNo < SUBC0_GINT8)
        {
            C0_EPORT0->EPIER |= (1u << GpioNo);
        }
        else if(GpioNo < SUBC0_WAKEUP0)
        {
            C0_EPORT1->EPIER |= (1u << (GpioNo - SUBC0_GINT8));
        }
        else//wake up
        {

        }
    }
    else
    {
        if (GpioNo < SUBC0_GINT8)
        {
            C0_EPORT0->EPIER &= ~(1u << GpioNo);
        }
        else if(GpioNo < SUBC0_WAKEUP0)
        {
            C0_EPORT1->EPIER &= ~(1u << (GpioNo - SUBC0_GINT8));
        }
        else//wake up
        {
            
        }
        
    }
}

/**
 * @brief drv_SubC0_ClearINTFlag 
 * @return uint32_t 
 */
uint32_t drv_SubC0_ClearINTFlag(void)
{
    uint32_t timeout = 3600; // 30us
    /* 清中断标志位 */               

    CPM->CPM_CHIPCFGR |= (1u << 20);       // Sub System to Main System Interrupt Clear
    while (CPM->CPM_CHIPCFGR & (1u << 21)) // clear 源头
    {
        timeout--;
        if (timeout == 0)
        {
            return STATUS_BUSY;
        }
    }
    CPM->CPM_CHIPCFGR &= ~(1u << 20);
    CPM->CPM_PADWKINTCR |= (1u << 7);
    return STATUS_OK;
}


/**
 * @brief 
 * 
 * @param GpioNo 
 * @param Pull 
 * @return uint32_t 
 */
uint32_t drv_Subc0_configIOPull(SubC0_PINx GpioNo, eSubC0_PULL Pull)
{
    EPORT_TypeDef *eport;
    uint8_t offset = GpioNo % 8;
    volatile uint32_t *pu32_SubC0_ioctrl_eport = (uint32_t *)0x0814601C; // eport0

    if (GpioNo > SUBC0_WAKEUP1)
    {
        return STATUS_UNKNOW_ERR;
    }

    if (GpioNo < SUBC0_GINT8)
    {
        eport = C0_EPORT0;
    }
    else if (GpioNo < SUBC0_WAKEUP0)
    {
        eport = C0_EPORT1;
        pu32_SubC0_ioctrl_eport = (uint32_t *)0x08146020; // eport1
    }
    else // wakeup pin
    {
        volatile uint32_t *pu32_CPM_WKPCSR = (uint32_t *)0x0814009C;
        volatile uint32_t *pu32_CPM_WKPPADCR = (uint32_t *)0x081400C8;
        if (Pull == SUBC0_DISPULL)
        {
            *pu32_CPM_WKPCSR &= ~(1u << (12 + offset));  // pullup
            *pu32_CPM_WKPPADCR &= ~(1u << (4 + offset)); // pulldown
        }
        else if (Pull == SUBC0_PULLUP)
        {
            *pu32_CPM_WKPCSR |= (1u << (12 + offset));   // pullup
            *pu32_CPM_WKPPADCR &= ~(1u << (4 + offset)); // pulldown
        }
        else if (Pull == SUBC0_PULLDOWN)
        {
            *pu32_CPM_WKPCSR &= ~(1u << (12 + offset)); // pullup
            *pu32_CPM_WKPPADCR |= (1u << (4 + offset)); // pulldown
        }
        return STATUS_OK;
    }

    if (Pull == SUBC0_DISPULL)
    {
        eport->EPPUER &= ~(1u << offset);
        *pu32_SubC0_ioctrl_eport &= ~(1u << (16 + offset));
    }
    else if (Pull == SUBC0_PULLUP)
    {
        eport->EPPUER |= (1u << offset);
        *pu32_SubC0_ioctrl_eport &= ~(1u << (16 + offset));
    }
    else if (Pull == SUBC0_PULLDOWN)
    {
        eport->EPPUER &= ~(1u << offset);
        *pu32_SubC0_ioctrl_eport |= (1u << (16 + offset));
    }
    return STATUS_OK;
}

/**
 * @brief 配置C0寄存器.
 *
 */
uint32_t drv_SubC0_initSys(void)
{
    drv_SubC0_sendM2S(); // 唤醒C0
    //    drv_SubC0_reset();
    CPM->CPM_SLPCFGR2 |= (1 << 23); // s2m_intm_sgl
    // the first time to init c0.
    CPM->CPM_CHIPCFGR &= ~(1 << 18); // disable sub system to main system power status isolation.
    while ((CPM->CPM_PWRSR & (1 << 4)) == 0)
        ;                            // wait for c0sub system power ready.
    CPM->CPM_CHIPCFGR &= ~(1 << 19); // disable sub system to main system output isolation.
    while ((CPM->CPM_PWRSR & 0x2100) != 0x2100)
        ;       // wait for m2s bus ready & bus reset released.
    delay(400); // delay 20us.

    return STATUS_OK;
}

/**
 * @brief
 * 
 * @param[in] hSubC0
 * @return uint32_t
 */
uint32_t drv_SubC0_initStruct(SubC0_HandleTypeDef *hSubC0)
{
    //    if (drv_SubC0_waitReady(3600) != STATUS_OK)
    //    {
    //        return STATUS_BUSY;
    //    }

    hSubC0->Lock = 1;
    hSubC0->Mask = SUBCO_NOINIT;
    hSubC0->gint0.Function = (e_SubC0_IOFuction)C0_GINT0_FUNCTION;
    hSubC0->gint1.Function = (e_SubC0_IOFuction)C0_GINT1_FUNCTION;
    hSubC0->gint4.Function = (e_SubC0_IOFuction)C0_GINT4_FUNCTION;
    hSubC0->gint5.Function = (e_SubC0_IOFuction)C0_GINT5_FUNCTION;
    hSubC0->wakeup0.Function = (e_SubC0_IOFuction)C0_WAKEUP0_FUNCTION;
    hSubC0->wakeup1.Function = (e_SubC0_IOFuction)C0_WAKEUP1_FUNCTION;
    hSubC0->gint0.Pull = (e_SubC0_IOPull)C0_GINT0_PULL;
    hSubC0->gint1.Pull = (e_SubC0_IOPull)C0_GINT1_PULL;
    hSubC0->gint4.Pull = (e_SubC0_IOPull)C0_GINT4_PULL;
    hSubC0->gint5.Pull = (e_SubC0_IOPull)C0_GINT5_PULL;
    hSubC0->wakeup0.Pull = (e_SubC0_IOPull)C0_WAKEUP0_PULL;
    hSubC0->wakeup1.Pull = (e_SubC0_IOPull)C0_WAKEUP1_PULL;
    hSubC0->Lock = 0;
    return STATUS_OK;
}

/**
 * @brief 配置SubC0 6个IO的中断唤醒触发模式.
 * 1. c0 init
 * 2. 配置C0 6个IO中断触发模式
 * 3. load exe to C0 SRAM, then run it.
 * 4. open NVIC
 * @param[in] hSubC0
 * @return uint32_t
 * @todo C0上电判断?
 */
uint32_t drv_SubC0_init(SubC0_HandleTypeDef *hSubC0)
{
    drv_SubC0_initSys();
    drv_SubC0_SoftPOR();
    drv_SubC0_initStruct(hSubC0);

    if (C0_CPM->CPM_SRSTMASKR & 0x80000000) //首次唤醒，则load代码到C0 sram
                                            //    if ((C0_CPM->CPM_PWRINDICR & 0x80000000) == 0) //首次唤醒，则load代码到C0 sram
    {
        drv_SubC0_loadBin((uint8_t *)g_C0BIN_LPWAKEUP, sizeof(g_C0BIN_LPWAKEUP) / sizeof(uint8_t));
        //        C0_CPM->CPM_PWRINDICR = (1u << 7);
        //        C0_CPM->CPM_PWRINDICR |= (1u << 15); // assert the reset of Core CS0.
        C0_CPM->CPM_SRSTMASKR &= ~0x80000000;
    }

    NVIC_Init(3, 3, SUBC0_IRQn, 2); //使能C0唤醒IO中断
    while (hSubC0->Mask != SUBCO_READY);
    return 0;
}

/**
 * @brief SubC0进入休眠
 * 
 * @return uint32_t 
 */
uint32_t drv_SubC0_sleep(void)
{
    while (hSubC0->Mask != SUBCO_READY);
    hSubC0->Lock = 1;
    hSubC0->Mask = SUBCO_SLEEP;
    hSubC0->Lock = 0;
    // C0_CPM->CPM_SLPCR = (1u << 0); //sleep

    CPM->CPM_PADWKINTCR |= (1u << 15);
    CPM->CPM_PADWKINTCR |= (1u << 23);

    return STATUS_OK;
}

/**
 * @brief 唤醒SubC0
 * 
 * @return uint32_t 
 */
uint32_t drv_SubC0_wakeup(void)
{
    drv_SubC0_sendM2S(); // 唤醒C0
    if (drv_SubC0_waitReady(7200) != STATUS_OK)
    {
        return STATUS_BUSY;
    }

    while (hSubC0->Mask != SUBCO_READY);
    // hSubC0->Lock = 1;
    // hSubC0->Mask = SUBCO_READY;
    // hSubC0->Lock = 0;

    CPM->CPM_PADWKINTCR &= ~(1u << 15);
    CPM->CPM_PADWKINTCR &= ~(1u << 23);
    while (CPM->CPM_PADWKINTCR & (1u << 7))
    {
        drv_SubC0_callback();
        CPM->CPM_PADWKINTCR |= (1u << 7);
    }

    NVIC->ICPR[0] = (1 << 14);      // clear cpm wake-up interrupt pending.
    NVIC_Init(3, 3, SUBC0_IRQn, 2); //使能C0唤醒IO中断

    return STATUS_OK;
}

/**
 * @brief 复位C0子系统.
 *
 * @param hSubC0
 * @return uint32_t
 */
uint32_t drv_SubC0_reset(void)
{
    drv_SubC0_sendM2S(); // 唤醒C0
    if (drv_SubC0_waitReady(7200) != STATUS_OK)
    {
        return STATUS_BUSY;
    }

    if ((CPM->CPM_PWRSR & 0x2100) == 0x2100) // c0 is not in lowpower mode.
    {
        C0_CPM->CPM_SRSTMASKR |= (1u << 31); //复位C0
        C0_CPM->CPM_SRSTMASKR &= ~(1u << 31);
    }
    else
    {

        C0_CPM->CPM_SRSTMASKR |= (1u << 31); //复位C0
        C0_CPM->CPM_SRSTMASKR &= ~(1u << 31);
    }
    return STATUS_OK;
}

/**
 * @brief 复位C0子系统.
 *
 * @param hSubC0
 * @return uint32_t
 */
uint32_t drv_SubC0_SoftPOR(void)
{
    C0_CPM->CPM_VCCQCTMR = 0x00000000;
    C0_CPM->CPM_VCCQCTMR = 0x40000000;
    C0_CPM->CPM_VCCQCTMR = 0x80000000;
    C0_CPM->CPM_VCCQCTMR = 0xc0000000;
    C0_CPM->CPM_VCCQCTMR = 0xc0000000 | 0x00000008;

    delay(600); //delay must more than 20us.

    CPM->CPM_MULTIRSTCR |= (1 << 4);
    CPM->CPM_SYSRSTCR |= (1 << 22); //reset M2S_BUS.
    delay(300);                     //delay must more than 10us.
    CPM->CPM_MULTIRSTCR &= ~(1 << 4);
    CPM->CPM_SYSRSTCR &= ~(1 << 22);
    delay(300); //delay must more than 10us.

    return STATUS_OK;
}

/**
 * @brief 区分SubC0 gpio唤醒源.
 * 
 * @param[out] pu32_wakeupSource 输出SubC0唤醒源到不掉电寄存器.
 * @return uint32_t 返回0, 则检测到了SubC0唤醒.
 */
uint32_t drv_SubC0_getWakeupSource(volatile uint32_t *pu32_wakeupSource)
{
    const volatile uint32_t CPM_PADWKINTCR = CPM->CPM_PADWKINTCR;
    if (CPM_PADWKINTCR & (1u << 7))
    {
        drv_SubC0_sendM2S(); // 唤醒C0
        if (drv_SubC0_waitReady(7200) != STATUS_OK)
        {
            return STATUS_BUSY;
        }

        hSubC0 = (SubC0_HandleTypeDef *)C0SRAM_ADD_BUFFER;
        hSubC0->Lock = 1;
        hSubC0->Mask = SUBCO_READY;
        hSubC0->Lock = 0;

        // drv_SubC0_wakeup();
#if CPM_HANDLEWAKEUP_C0GINT0
        if (hSubC0->gint0.IE != 0)
        {
            hSubC0->gint0.IE = 0;
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN0;
            return STATUS_OK;
        }
#endif
#if CPM_HANDLEWAKEUP_C0GINT1
        if (hSubC0->gint1.IE != 0)
        {
            hSubC0->gint1.IE = 0;
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN1;
            return STATUS_OK;
        }
#endif
#if CPM_HANDLEWAKEUP_C0GINT4
        if (hSubC0->gint4.IE != 0)
        {
            hSubC0->gint4.IE = 0;
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN4;
            return STATUS_OK;
        }
#endif
#if CPM_HANDLEWAKEUP_C0GINT5
        if (hSubC0->gint5.IE != 0)
        {
            hSubC0->gint5.IE = 0;
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN5;
            return STATUS_OK;
        }
#endif
        drv_SubC0_sleep();
    }

#if 0
#if (CPM_HANDLEWAKEUP_C0GINT0 || \
     CPM_HANDLEWAKEUP_C0GINT1 || \
     CPM_HANDLEWAKEUP_C0GINT4 || \
     CPM_HANDLEWAKEUP_C0GINT5)

    drv_SubC0_wakeup();

#if CPM_HANDLEWAKEUP_C0GINT0
    if (C0_GINT0_FUNCTION == SUBC0_IO_INT_RISING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT0) == 1)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN0;
            return 0;
        }
    }
    else if (C0_GINT0_FUNCTION == SUBC0_IO_INT_FALLING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT0) == 0)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN0;
            return 0;
        }
    }
#endif

#if CPM_HANDLEWAKEUP_C0GINT1
    if (C0_GINT1_FUNCTION == SUBC0_IO_INT_RISING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT1) == 1)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN1;
            return 0;
        }
    }
    else if (C0_GINT1_FUNCTION == SUBC0_IO_INT_FALLING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT1) == 0)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN1;
            return 0;
        }
    }
#endif
#if CPM_HANDLEWAKEUP_C0GINT4
    if (C0_GINT4_FUNCTION == SUBC0_IO_INT_RISING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT4) == 1)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN4;
            return 0;
        }
    }
    else if (C0_GINT4_FUNCTION == SUBC0_IO_INT_FALLING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT4) == 0)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN4;
            return 0;
        }
    }
#endif

#if CPM_HANDLEWAKEUP_C0GINT5
    if (C0_GINT5_FUNCTION == SUBC0_IO_INT_RISING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT5) == 1)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN5;
            return 0;
        }
    }
    else if (C0_GINT5_FUNCTION == SUBC0_IO_INT_FALLING_EDGE)
    {
        if (drv_SubC0_ReadGpioData(SUBC0_GINT5) == 0)
        {
            *pu32_wakeupSource = WAKEUP_SOURCE_C0GIN5;
            return 0;
        }
    }
#endif
#endif
    drv_SubC0_sleep();
#endif
    return STATUS_UNKNOW_ERR;
}
